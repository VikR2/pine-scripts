//@version=6
indicator("80m Cycles - Full Strategy", overlay = true, max_boxes_count = 500, max_lines_count = 500, max_labels_count = 500)

// ══════════════════════════════════════════════════════════════════════════════
// 80-MINUTE CYCLE STRATEGY INDICATOR
// ══════════════════════════════════════════════════════════════════════════════
// Divides trading day into 80-minute cycles with 40-minute accumulation and
// 40-minute execution phases. Detects liquidity sweeps, CSD signals, and
// provides trade management overlays.
// ══════════════════════════════════════════════════════════════════════════════

// ── INPUTS ─────────────────────────────────────────────────────────────────────
grp_time   = "Time Settings (EST)"
tz         = "America/New_York"
startH     = input.int(7,  "Session Start Hour", minval=0, maxval=23, group = grp_time)
startM     = input.int(0,  "Session Start Minute", minval=0, maxval=59, group = grp_time)
endH       = input.int(16, "Session End Hour", minval=0, maxval=23, group = grp_time)
endM       = input.int(0,  "Session End Minute", minval=0, maxval=59, group = grp_time)

grp_visual = "Visual Settings"
colSession = input.color(color.new(color.gray, 97), "Full Session Background", group = grp_visual)
col80m     = input.color(color.new(color.gray, 92), "80min Cycle Box", group = grp_visual)
col40m     = input.color(color.new(color.rgb(100, 140, 160), 88), "Accumulation Phase Shade", group = grp_visual)
borderCol  = input.color(color.new(color.gray, 70), "Borders", group = grp_visual)

grp_levels = "Level Lines"
drawLevels     = input.bool(true, "Draw Accumulation Levels?", group = grp_levels)
colOpen        = input.color(color.white, "Cycle Open Line", group = grp_levels)
colHigh        = input.color(color.red, "40m High Line", group = grp_levels)
colLow         = input.color(color.green, "40m Low Line", group = grp_levels)
colEQ          = input.color(color.orange, "Equilibrium Line", group = grp_levels)

grp_zones = "Premium/Discount Zones"
drawZones      = input.bool(true, "Draw Premium/Discount Zones?", group = grp_zones)
colPremium     = input.color(color.new(color.red, 90), "Premium Zone (Sell)", group = grp_zones)
colDiscount    = input.color(color.new(color.green, 90), "Discount Zone (Buy)", group = grp_zones)

grp_signals = "Signal Detection"
drawSignals    = input.bool(true, "Show CSD Signals?", group = grp_signals)
colBuySignal   = input.color(color.lime, "Buy Signal", group = grp_signals)
colSellSignal  = input.color(color.red, "Sell Signal", group = grp_signals)
colHighRisk    = input.color(color.orange, "High Risk Signal", group = grp_signals)

grp_ob = "Order Blocks"
drawOB         = input.bool(true, "Show Order Blocks?", group = grp_ob)
colBullOB      = input.color(color.new(color.green, 80), "Bullish OB", group = grp_ob)
colBearOB      = input.color(color.new(color.red, 80), "Bearish OB", group = grp_ob)

grp_risk = "Trade Management"
riskThreshold  = input.float(20.0, "Max Stop Distance (Points)", minval=1.0, group = grp_risk)
profitTarget   = input.float(70.0, "Profit Target (Points)", minval=10.0, group = grp_risk)
partialTarget  = input.float(50.0, "Partial Profit Target (Points)", minval=10.0, group = grp_risk)

grp_bias = "Bias/Environment"
drawBias       = input.bool(true, "Show Environment Labels?", group = grp_bias)
eqWiggleATR    = input.float(0.3, "EQ Wiggle Threshold (ATR mult)", minval=0.1, maxval=1.0, step=0.1, group = grp_bias)

grp_lines  = "Opening Lines"
drawLines  = input.bool(true, "Draw Open Price Lines?", group = grp_lines)
openTimesInput = input.string("07:00", "Opening Time(s) (HH:MM, comma-separated)", group = grp_lines)
colLine    = input.color(color.gray, "Line Color", group = grp_lines)

// ── TIME CALCULATIONS ──────────────────────────────────────────────────────────
y = year(time, tz)
m = month(time, tz)
d = dayofmonth(time, tz)

t_sess_start = timestamp(tz, y, m, d, startH, startM, 0)
t_sess_end   = timestamp(tz, y, m, d, endH, endM, 0)

ms_80 = 80 * 60 * 1000
ms_40 = 40 * 60 * 1000

in_session_window = time >= t_sess_start and time < t_sess_end

// ── CYCLE INDEX CALCULATION ────────────────────────────────────────────────────
i_cyc = if in_session_window
    ms_elapsed = time - t_sess_start
    math.floor(ms_elapsed / ms_80)
else
    -1

is_new_cycle = i_cyc != i_cyc[1] and i_cyc >= 0

t_cycle_start = t_sess_start + (i_cyc * ms_80)
t_cycle_end   = t_cycle_start + ms_80
t_sub_end     = t_cycle_start + ms_40

// Phase detection
in_accumulation = time >= t_cycle_start and time < t_sub_end
in_execution    = time >= t_sub_end and time < t_cycle_end

// ── STATE VARIABLES ────────────────────────────────────────────────────────────
// Session state
var box b_sess = na
var float h_sess = na, var float l_sess = na

// Cycle state
var box b_cyc = na
var box b_sub = na
var float h_cyc = na, var float l_cyc = na
var float h_sub = na, var float l_sub = na
var float cycle_open = na

// Level lines
var line l_open = na
var line l_high = na
var line l_low = na
var line l_eq = na

// Premium/Discount zone boxes
var box b_premium = na
var box b_discount = na

// Signal state
var bool high_swept = false
var bool low_swept = false
var float sweep_price = na
var int sweep_bar = na
var bool csd_triggered = false
var float entry_price = na
var float stop_price = na
var int signal_direction = 0  // 1 = buy, -1 = sell

// Order Block state
var box ob_box = na
var float ob_top = na
var float ob_bottom = na

// Environment state
var label env_label = na

// Opening lines state
var line[] openLines = array.new_line()
var float[] openPrices = array.new_float()
var bool[] openActive = array.new_bool()
var int[] openStartIdx = array.new_int()
var int[] openHours = array.new_int()
var int[] openMinutes = array.new_int()

// ── HELPERS ────────────────────────────────────────────────────────────────────
parse_open_time(txt) =>
    clean = str.replace_all(txt, " ", "")
    parts = str.split(clean, ":")
    has_two_parts = array.size(parts) == 2
    h_raw = has_two_parts ? str.tonumber(array.get(parts, 0)) : na
    m_raw = has_two_parts ? str.tonumber(array.get(parts, 1)) : na
    h_int = not na(h_raw) ? int(math.round(h_raw)) : na
    m_int = not na(m_raw) ? int(math.round(m_raw)) : na
    is_valid = has_two_parts and not na(h_int) and not na(m_int) and h_int >= 0 and h_int < 24 and m_int >= 0 and m_int < 60
    [is_valid ? h_int : na, is_valid ? m_int : na]

init_open_times() =>
    array.clear(openHours)
    array.clear(openMinutes)
    parts = str.split(openTimesInput, ",")
    if array.size(parts) > 0
        for i = 0 to array.size(parts) - 1
            part = array.get(parts, i)
            [h, m_] = parse_open_time(part)
            if not na(h) and not na(m_)
                array.push(openHours, h)
                array.push(openMinutes, m_)

reset_open_lines() =>
    if array.size(openLines) > 0
        for i = 0 to array.size(openLines) - 1
            line.delete(array.get(openLines, i))
    array.clear(openLines)
    array.clear(openPrices)
    array.clear(openActive)
    array.clear(openStartIdx)

// Calculate ATR for wiggle detection
atr_val = ta.atr(14)

// Candle type detection
is_bullish = close > open
is_bearish = close < open

// Initialize configured opening times once on load
if barstate.isfirst
    init_open_times()

// ══════════════════════════════════════════════════════════════════════════════
// EXECUTION LOGIC
// ══════════════════════════════════════════════════════════════════════════════

// ── 1. SESSION MANAGEMENT ──────────────────────────────────────────────────────
is_start_of_day = time >= t_sess_start and time[1] < t_sess_start

if is_start_of_day
    h_sess := high
    l_sess := low
    b_sess := box.new(t_sess_start, high, t_sess_end, low, xloc=xloc.bar_time, border_color=na, bgcolor=colSession)
    reset_open_lines()

if in_session_window
    new_h_sess = math.max(h_sess, high)
    new_l_sess = math.min(l_sess, low)

    if new_h_sess != h_sess
        h_sess := new_h_sess
        box.set_top(b_sess, h_sess)

    if new_l_sess != l_sess
        l_sess := new_l_sess
        box.set_bottom(b_sess, l_sess)

    // Create new opening price lines at configured times
    if drawLines and array.size(openHours) > 0
        for i = 0 to array.size(openHours) - 1
            ts_open = timestamp(tz, y, m, d, array.get(openHours, i), array.get(openMinutes, i), 0)
            is_new_open = time >= ts_open and time[1] < ts_open
            if is_new_open
                price = open
                l = line.new(ts_open, price, time, price, xloc=xloc.bar_time, color=colLine, style=line.style_dotted)
                array.push(openLines, l)
                array.push(openPrices, price)
                array.push(openActive, true)
                array.push(openStartIdx, bar_index)

    // Manage existing opening price lines
    if array.size(openLines) > 0
        for i = 0 to array.size(openLines) - 1
            l = array.get(openLines, i)
            price = array.get(openPrices, i)
            is_active = array.get(openActive, i)
            start_idx = array.get(openStartIdx, i)
            if is_active
                traded_to_price = bar_index > start_idx and high >= price and low <= price
                if traded_to_price
                    line.set_x2(l, time)
                    array.set(openActive, i, false)
                else
                    line.set_x2(l, time)

// ── 2. CYCLE MANAGEMENT ────────────────────────────────────────────────────────
if in_session_window
    // NEW CYCLE START
    if is_new_cycle
        // Reset all state
        h_cyc := high
        l_cyc := low
        h_sub := high
        l_sub := low
        cycle_open := open

        // Reset signal state
        high_swept := false
        low_swept := false
        sweep_price := na
        sweep_bar := na
        csd_triggered := false
        entry_price := na
        stop_price := na
        signal_direction := 0

        // Delete previous cycle's level lines
        line.delete(l_open)
        line.delete(l_high)
        line.delete(l_low)
        line.delete(l_eq)
        box.delete(b_premium)
        box.delete(b_discount)
        box.delete(ob_box)
        label.delete(env_label)

        // Reset line/box vars
        l_open := na
        l_high := na
        l_low := na
        l_eq := na
        b_premium := na
        b_discount := na
        ob_box := na
        ob_top := na
        ob_bottom := na
        env_label := na

        // Create Boxes
        b_cyc := box.new(t_cycle_start, high, t_cycle_end, low, xloc=xloc.bar_time, border_color=borderCol, bgcolor=col80m)
        b_sub := box.new(t_cycle_start, high, t_sub_end, low, xloc=xloc.bar_time, border_color=na, bgcolor=col40m)

    // UPDATE 80m BOX
    new_h_cyc = math.max(h_cyc, high)
    new_l_cyc = math.min(l_cyc, low)

    if new_h_cyc != h_cyc
        h_cyc := new_h_cyc
        box.set_top(b_cyc, h_cyc)

    if new_l_cyc != l_cyc
        l_cyc := new_l_cyc
        box.set_bottom(b_cyc, l_cyc)

    // UPDATE 40m BOX (Only in accumulation phase)
    if in_accumulation
        new_h_sub = math.max(h_sub, high)
        new_l_sub = math.min(l_sub, low)

        if new_h_sub != h_sub
            h_sub := new_h_sub
            box.set_top(b_sub, h_sub)

        if new_l_sub != l_sub
            l_sub := new_l_sub
            box.set_bottom(b_sub, l_sub)

// ── 3. LEVEL PROJECTION (at transition to execution phase) ────────────────────
is_phase_transition = in_execution and in_accumulation[1]

if is_phase_transition and drawLevels
    eq_price = (h_sub + l_sub) / 2

    // Create level lines projecting into execution phase
    l_open := line.new(t_sub_end, cycle_open, t_cycle_end, cycle_open, xloc=xloc.bar_time, color=colOpen, style=line.style_solid, width=1)
    l_high := line.new(t_sub_end, h_sub, t_cycle_end, h_sub, xloc=xloc.bar_time, color=colHigh, style=line.style_dashed, width=1)
    l_low  := line.new(t_sub_end, l_sub, t_cycle_end, l_sub, xloc=xloc.bar_time, color=colLow, style=line.style_dashed, width=1)
    l_eq   := line.new(t_sub_end, eq_price, t_cycle_end, eq_price, xloc=xloc.bar_time, color=colEQ, style=line.style_dotted, width=2)

    // Add labels for levels
    label.new(t_sub_end, cycle_open, "OPEN", xloc=xloc.bar_time, style=label.style_label_left, color=color.new(colOpen, 80), textcolor=colOpen, size=size.tiny)
    label.new(t_sub_end, h_sub, "40m HIGH", xloc=xloc.bar_time, style=label.style_label_left, color=color.new(colHigh, 80), textcolor=colHigh, size=size.tiny)
    label.new(t_sub_end, l_sub, "40m LOW", xloc=xloc.bar_time, style=label.style_label_left, color=color.new(colLow, 80), textcolor=colLow, size=size.tiny)
    label.new(t_sub_end, eq_price, "EQ", xloc=xloc.bar_time, style=label.style_label_left, color=color.new(colEQ, 80), textcolor=colEQ, size=size.tiny)

// ── 4. PREMIUM/DISCOUNT ZONES ──────────────────────────────────────────────────
if is_phase_transition and drawZones
    eq_price = (h_sub + l_sub) / 2

    // Premium zone (above EQ) - sell zone
    b_premium := box.new(t_sub_end, h_sub, t_cycle_end, eq_price, xloc=xloc.bar_time, border_color=na, bgcolor=colPremium)

    // Discount zone (below EQ) - buy zone
    b_discount := box.new(t_sub_end, eq_price, t_cycle_end, l_sub, xloc=xloc.bar_time, border_color=na, bgcolor=colDiscount)

// ── 5. BIAS/ENVIRONMENT LOGIC ──────────────────────────────────────────────────
if in_execution and drawBias
    eq_price = (h_sub + l_sub) / 2
    wiggle_zone = atr_val * eqWiggleATR

    // Detect environment
    price_above_eq = close > eq_price + wiggle_zone
    price_below_eq = close < eq_price - wiggle_zone
    price_at_eq = close >= eq_price - wiggle_zone and close <= eq_price + wiggle_zone

    // Update environment label
    label.delete(env_label)

    if price_above_eq
        env_label := label.new(bar_index, high + atr_val * 0.5, "PREMIUM\nExpansion", style=label.style_label_down, color=color.new(color.red, 70), textcolor=color.white, size=size.small)
    else if price_below_eq
        env_label := label.new(bar_index, low - atr_val * 0.5, "DISCOUNT\nExpansion", style=label.style_label_up, color=color.new(color.green, 70), textcolor=color.white, size=size.small)
    else if price_at_eq
        env_label := label.new(bar_index, eq_price, "CONSOLIDATION\nStop Trading", style=label.style_label_center, color=color.new(color.gray, 50), textcolor=color.white, size=size.small)

// ── 6. LIQUIDITY SWEEP DETECTION ───────────────────────────────────────────────
if in_execution and not csd_triggered
    // Detect sweep of 40m High (bearish setup)
    if high > h_sub and not high_swept
        high_swept := true
        sweep_price := high
        sweep_bar := bar_index

    // Detect sweep of 40m Low (bullish setup)
    if low < l_sub and not low_swept
        low_swept := true
        sweep_price := low
        sweep_bar := bar_index

// ── 7. CSD (CHANGE IN STATE OF DELIVERY) SIGNALS ───────────────────────────────
if in_execution and drawSignals and not csd_triggered

    // BUY SIGNAL: After low sweep, first down candle traded above/closed above
    if low_swept and bar_index > sweep_bar
        // Look for the trigger: price action returning above the down candle
        if is_bearish[1] and (close > high[1] or high > high[1])
            csd_triggered := true
            entry_price := close
            stop_price := l_sub  // Stop below 40m low
            signal_direction := 1

            stop_distance = math.abs(entry_price - stop_price)
            is_high_risk = stop_distance > riskThreshold

            // Draw signal
            signal_color = is_high_risk ? colHighRisk : colBuySignal
            label.new(bar_index, low - atr_val * 0.3, is_high_risk ? "BUY\nHIGH RISK\n" + str.tostring(stop_distance, "#.#") + " pts" : "BUY\nCSD", style=label.style_label_up, color=signal_color, textcolor=color.white, size=size.normal)

            // Alert
            if is_high_risk
                alert("CSD BUY Signal - HIGH RISK: Stop distance " + str.tostring(stop_distance, "#.#") + " points exceeds " + str.tostring(riskThreshold) + " point threshold", alert.freq_once_per_bar)
            else
                alert("CSD BUY Signal triggered at " + str.tostring(close), alert.freq_once_per_bar)

    // SELL SIGNAL: After high sweep, first up candle traded below/closed below
    if high_swept and bar_index > sweep_bar
        // Look for the trigger: price action returning below the up candle
        if is_bullish[1] and (close < low[1] or low < low[1])
            csd_triggered := true
            entry_price := close
            stop_price := h_sub  // Stop above 40m high
            signal_direction := -1

            stop_distance = math.abs(stop_price - entry_price)
            is_high_risk = stop_distance > riskThreshold

            // Draw signal
            signal_color = is_high_risk ? colHighRisk : colSellSignal
            label.new(bar_index, high + atr_val * 0.3, is_high_risk ? "SELL\nHIGH RISK\n" + str.tostring(stop_distance, "#.#") + " pts" : "SELL\nCSD", style=label.style_label_down, color=signal_color, textcolor=color.white, size=size.normal)

            // Alert
            if is_high_risk
                alert("CSD SELL Signal - HIGH RISK: Stop distance " + str.tostring(stop_distance, "#.#") + " points exceeds " + str.tostring(riskThreshold) + " point threshold", alert.freq_once_per_bar)
            else
                alert("CSD SELL Signal triggered at " + str.tostring(close), alert.freq_once_per_bar)

// ── 8. ORDER BLOCK IDENTIFICATION ──────────────────────────────────────────────
if in_execution and drawOB and csd_triggered and na(ob_box)

    // Bullish Order Block: Last down candle before up move that breaks structure
    if signal_direction == 1
        // Look back for the last bearish candle before the bullish move
        for i = 1 to 10
            if close[i] < open[i]  // Found a bearish candle
                ob_top := high[i]
                ob_bottom := low[i]
                ob_box := box.new(bar_index[i], ob_top, bar_index + 5, ob_bottom, border_color=color.green, bgcolor=colBullOB, border_width=1)
                label.new(bar_index[i], ob_bottom, "OB", style=label.style_label_up, color=color.new(color.green, 70), textcolor=color.white, size=size.tiny)
                break

    // Bearish Order Block: Last up candle before down move that breaks structure
    if signal_direction == -1
        // Look back for the last bullish candle before the bearish move
        for i = 1 to 10
            if close[i] > open[i]  // Found a bullish candle
                ob_top := high[i]
                ob_bottom := low[i]
                ob_box := box.new(bar_index[i], ob_top, bar_index + 5, ob_bottom, border_color=color.red, bgcolor=colBearOB, border_width=1)
                label.new(bar_index[i], ob_top, "OB", style=label.style_label_down, color=color.new(color.red, 70), textcolor=color.white, size=size.tiny)
                break

// ── 9. TRADE MANAGEMENT / PROFIT TARGET ALERTS ─────────────────────────────────
if csd_triggered and not na(entry_price)
    current_profit = signal_direction == 1 ? (close - entry_price) : (entry_price - close)

    // Partial profit target reached
    if current_profit >= partialTarget and current_profit < profitTarget
        alert("Partial Profit Target (" + str.tostring(partialTarget) + " pts) reached! Consider taking partial profits.", alert.freq_once_per_bar)

    // Full profit target reached - move to break even
    if current_profit >= profitTarget
        label.new(bar_index, signal_direction == 1 ? high + atr_val * 0.5 : low - atr_val * 0.5, "TP\n" + str.tostring(profitTarget) + " pts\nMove to BE", style=signal_direction == 1 ? label.style_label_down : label.style_label_up, color=color.new(color.blue, 50), textcolor=color.white, size=size.small)
        alert("Profit Target (" + str.tostring(profitTarget) + " pts) reached! Move stop to break even and take profits.", alert.freq_once_per_bar)

// ══════════════════════════════════════════════════════════════════════════════
// VISUAL ENHANCEMENTS
// ══════════════════════════════════════════════════════════════════════════════

// Plot current cycle phase info on chart
var table infoTable = table.new(position.top_right, 2, 4, bgcolor=color.new(color.black, 80), border_width=1)

if barstate.islast and in_session_window
    cycle_num = i_cyc + 1
    phase_text = in_accumulation ? "ACCUMULATION" : "EXECUTION"
    phase_color = in_accumulation ? color.yellow : color.lime

    eq_price = (h_sub + l_sub) / 2

    table.cell(infoTable, 0, 0, "Cycle", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 0, str.tostring(cycle_num), text_color=color.white, text_size=size.small)
    table.cell(infoTable, 0, 1, "Phase", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 1, phase_text, text_color=phase_color, text_size=size.small)
    table.cell(infoTable, 0, 2, "40m Range", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(h_sub - l_sub, "#.##"), text_color=color.white, text_size=size.small)
    table.cell(infoTable, 0, 3, "EQ", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 3, str.tostring(eq_price, "#.##"), text_color=colEQ, text_size=size.small)

// ══════════════════════════════════════════════════════════════════════════════
// CYCLE TIME REFERENCE (for debugging/reference)
// ══════════════════════════════════════════════════════════════════════════════
// Cycle 1: 07:00 - 08:20
// Cycle 2: 08:20 - 09:40
// Cycle 3: 09:40 - 11:00
// Cycle 4: 11:00 - 12:20
// Cycle 5: 12:20 - 13:40
// Cycle 6: 13:40 - 15:00
// Cycle 7: 15:00 - 16:00 (truncated if session ends at 16:00)
// ══════════════════════════════════════════════════════════════════════════════
