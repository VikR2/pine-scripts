//@version=6
strategy("80m Cycles Strategy", overlay=true, default_qty_type=strategy.fixed, default_qty_value=1, initial_capital=10000, use_bar_magnifier=true)

// ══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════════════════
tz = "America/New_York"
startH = input.int(7, "Session Start Hour")
endH = input.int(16, "Session End Hour")
stopPts = input.float(30.0, "Stop Points")
tpPts = input.float(70.0, "TP Points")

// ══════════════════════════════════════════════════════════════════════════════
// TIME CALCULATIONS
// ══════════════════════════════════════════════════════════════════════════════
y = year(time, tz)
mo = month(time, tz)
d = dayofmonth(time, tz)

sessStart = timestamp(tz, y, mo, d, startH, 0, 0)
sessEnd = timestamp(tz, y, mo, d, endH, 0, 0)

ms80 = 80 * 60 * 1000
ms40 = 40 * 60 * 1000

inSession = time >= sessStart and time < sessEnd
cycleIdx = inSession ? math.floor((time - sessStart) / ms80) : -1
newCycle = cycleIdx != cycleIdx[1] and cycleIdx >= 0

cycleStart = sessStart + (cycleIdx * ms80)
phase2Start = cycleStart + ms40
cycleEnd = cycleStart + ms80

inPhase1 = time >= cycleStart and time < phase2Start
inPhase2 = time >= phase2Start and time < cycleEnd

// ══════════════════════════════════════════════════════════════════════════════
// TRACK RANGE
// ══════════════════════════════════════════════════════════════════════════════
var float rangeHigh = na
var float rangeLow = na

if newCycle
    rangeHigh := high
    rangeLow := low

if inPhase1
    rangeHigh := math.max(nz(rangeHigh, high), high)
    rangeLow := math.min(nz(rangeLow, low), low)

// ══════════════════════════════════════════════════════════════════════════════
// DETECT SWEEPS - Simple version
// ══════════════════════════════════════════════════════════════════════════════
sweepHigh = inPhase2 and not na(rangeHigh) and high > rangeHigh
sweepLow = inPhase2 and not na(rangeLow) and low < rangeLow

// Prevent multiple signals per cycle
var int lastLongCycle = -1
var int lastShortCycle = -1

longOK = cycleIdx != lastLongCycle
shortOK = cycleIdx != lastShortCycle

// ══════════════════════════════════════════════════════════════════════════════
// STRATEGY ENTRIES
// ══════════════════════════════════════════════════════════════════════════════
if sweepLow and longOK and strategy.position_size == 0
    lastLongCycle := cycleIdx
    strategy.entry("Long", strategy.long)

if sweepHigh and shortOK and strategy.position_size == 0
    lastShortCycle := cycleIdx
    strategy.entry("Short", strategy.short)

// Exits
if strategy.position_size > 0
    strategy.exit("LX", "Long", stop=strategy.position_avg_price - stopPts, limit=strategy.position_avg_price + tpPts)

if strategy.position_size < 0
    strategy.exit("SX", "Short", stop=strategy.position_avg_price + stopPts, limit=strategy.position_avg_price - tpPts)

// End of day
if time >= sessEnd and strategy.position_size != 0
    strategy.close_all("EOD")

// ══════════════════════════════════════════════════════════════════════════════
// VISUALS
// ══════════════════════════════════════════════════════════════════════════════
plotshape(sweepLow and longOK, "Long", shape.triangleup, location.belowbar, color.lime, size=size.small)
plotshape(sweepHigh and shortOK, "Short", shape.triangledown, location.abovebar, color.red, size=size.small)

plot(inPhase2 ? rangeHigh : na, "High", color.red, 1, plot.style_linebr)
plot(inPhase2 ? rangeLow : na, "Low", color.green, 1, plot.style_linebr)

bgcolor(inPhase1 ? color.new(color.yellow, 90) : inPhase2 ? color.new(color.blue, 93) : na)

// Debug - show trade count
var label lbl = na
label.delete(lbl)
if barstate.islast
    lbl := label.new(bar_index, high, "Closed: " + str.tostring(strategy.closedtrades) + "\nOpen: " + str.tostring(strategy.opentrades), style=label.style_label_down, color=color.blue)
