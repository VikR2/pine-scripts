//@version=6
strategy("80m Cycles Strategy", overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 100, initial_capital = 10000, commission_type = strategy.commission.cash_per_contract, commission_value = 2.5, slippage = 1)

// ══════════════════════════════════════════════════════════════════════════════
// 80-MINUTE CYCLE STRATEGY - BACKTESTER
// ══════════════════════════════════════════════════════════════════════════════

// ── STRATEGY INPUTS ────────────────────────────────────────────────────────────
grp_strat = "Strategy Settings"
entryMode      = input.string("Sweep Only", "Entry Mode", options=["Sweep Only", "Sweep + Reversal", "Full CSD"], group = grp_strat, tooltip="Sweep Only = enter on any sweep. Sweep+Reversal = sweep then opposite candle. Full CSD = strict pattern.")
useStopLoss    = input.bool(true, "Use Stop Loss", group = grp_strat)
stopAtLow      = input.bool(true, "Stop at 40m Low/High (vs Fixed Points)", group = grp_strat)
fixedStopPts   = input.float(20.0, "Fixed Stop Loss (Points)", minval=1.0, group = grp_strat)
useTakeProfit  = input.bool(true, "Use Take Profit", group = grp_strat)
takeProfitPts  = input.float(70.0, "Take Profit (Points)", minval=10.0, group = grp_strat)
useTrailStop   = input.bool(false, "Use Trailing Stop", group = grp_strat)
trailPts       = input.float(30.0, "Trail Points", minval=5.0, group = grp_strat)
maxRiskPts     = input.float(0.0, "Max Risk Filter (0=disabled)", minval=0.0, group = grp_strat)
onlyLongs      = input.bool(false, "Long Only", group = grp_strat)
onlyShorts     = input.bool(false, "Short Only", group = grp_strat)

// ── TIME INPUTS ────────────────────────────────────────────────────────────────
grp_time   = "Time Settings (EST)"
tz         = "America/New_York"
startH     = input.int(7,  "Session Start Hour", minval=0, maxval=23, group = grp_time)
startM     = input.int(0,  "Session Start Minute", minval=0, maxval=59, group = grp_time)
endH       = input.int(16, "Session End Hour", minval=0, maxval=23, group = grp_time)
endM       = input.int(0,  "Session End Minute", minval=0, maxval=59, group = grp_time)

// ── FILTER INPUTS ──────────────────────────────────────────────────────────────
grp_filter = "Trade Filters"
reqEQConfirm   = input.bool(false, "Require Discount/Premium Zone", group = grp_filter)
minRangeATR    = input.float(0.0, "Min 40m Range (ATR mult, 0=disabled)", minval=0.0, group = grp_filter)

// ── DEBUG INPUTS ───────────────────────────────────────────────────────────────
grp_debug = "Debug / Visual"
showBoxes      = input.bool(true, "Show Cycle Boxes", group = grp_debug)
showLevels     = input.bool(true, "Show Level Lines", group = grp_debug)
showSweeps     = input.bool(true, "Show Sweep Markers", group = grp_debug)
showDebugTable = input.bool(true, "Show Debug Table", group = grp_debug)
col80m         = input.color(color.new(color.gray, 92), "80min Cycle Box", group = grp_debug)
col40m         = input.color(color.new(color.rgb(100, 140, 160), 88), "Accumulation Phase", group = grp_debug)
colHigh        = input.color(color.red, "40m High", group = grp_debug)
colLow         = input.color(color.green, "40m Low", group = grp_debug)
colEQ          = input.color(color.orange, "Equilibrium", group = grp_debug)

// ── TIME CALCULATIONS ──────────────────────────────────────────────────────────
y = year(time, tz)
mo = month(time, tz)
d = dayofmonth(time, tz)

t_sess_start = timestamp(tz, y, mo, d, startH, startM, 0)
t_sess_end   = timestamp(tz, y, mo, d, endH, endM, 0)

ms_80 = 80 * 60 * 1000
ms_40 = 40 * 60 * 1000

in_session_window = time >= t_sess_start and time < t_sess_end

// ── CYCLE INDEX CALCULATION ────────────────────────────────────────────────────
i_cyc = if in_session_window
    ms_elapsed = time - t_sess_start
    math.floor(ms_elapsed / ms_80)
else
    -1

is_new_cycle = i_cyc != i_cyc[1] and i_cyc >= 0

t_cycle_start = t_sess_start + (i_cyc * ms_80)
t_cycle_end   = t_cycle_start + ms_80
t_sub_end     = t_cycle_start + ms_40

// Phase detection
in_accumulation = time >= t_cycle_start and time < t_sub_end
in_execution    = time >= t_sub_end and time < t_cycle_end

// ── STATE VARIABLES ────────────────────────────────────────────────────────────
var box b_cyc = na
var box b_sub = na
var float h_cyc = na, var float l_cyc = na
var float h_sub = na, var float l_sub = na
var float cycle_open = na

// Level lines
var line l_high = na
var line l_low = na
var line l_eq = na

// Signal state
var bool high_swept = false
var bool low_swept = false
var int sweep_bar = na
var bool trade_taken = false
var int trade_direction = 0

// Debug counters
var int total_cycles = 0
var int total_sweeps = 0
var int total_signals = 0

// ATR for filters
atr_val = ta.atr(14)

// Candle type detection
is_bullish = close > open
is_bearish = close < open

// ══════════════════════════════════════════════════════════════════════════════
// CYCLE MANAGEMENT
// ══════════════════════════════════════════════════════════════════════════════

if in_session_window
    // NEW CYCLE START
    if is_new_cycle
        total_cycles := total_cycles + 1

        // Reset state
        h_cyc := high
        l_cyc := low
        h_sub := high
        l_sub := low
        cycle_open := open

        // Reset signal state
        high_swept := false
        low_swept := false
        sweep_bar := na
        trade_taken := false
        trade_direction := 0

        // Delete previous lines
        line.delete(l_high)
        line.delete(l_low)
        line.delete(l_eq)
        box.delete(b_cyc)
        box.delete(b_sub)

        // Create boxes
        if showBoxes
            b_cyc := box.new(t_cycle_start, high, t_cycle_end, low, xloc=xloc.bar_time, border_color=color.gray, bgcolor=col80m)
            b_sub := box.new(t_cycle_start, high, t_sub_end, low, xloc=xloc.bar_time, border_color=na, bgcolor=col40m)

    // Update cycle high/low
    new_h_cyc = math.max(h_cyc, high)
    new_l_cyc = math.min(l_cyc, low)

    if new_h_cyc != h_cyc
        h_cyc := new_h_cyc
        if showBoxes and not na(b_cyc)
            box.set_top(b_cyc, h_cyc)

    if new_l_cyc != l_cyc
        l_cyc := new_l_cyc
        if showBoxes and not na(b_cyc)
            box.set_bottom(b_cyc, l_cyc)

    // Update 40m box (accumulation only)
    if in_accumulation
        new_h_sub = math.max(h_sub, high)
        new_l_sub = math.min(l_sub, low)

        if new_h_sub != h_sub
            h_sub := new_h_sub
            if showBoxes and not na(b_sub)
                box.set_top(b_sub, h_sub)

        if new_l_sub != l_sub
            l_sub := new_l_sub
            if showBoxes and not na(b_sub)
                box.set_bottom(b_sub, l_sub)

// ── LEVEL PROJECTION ───────────────────────────────────────────────────────────
is_phase_transition = in_execution and in_accumulation[1]

if is_phase_transition and showLevels
    eq_price_draw = (h_sub + l_sub) / 2
    l_high := line.new(t_sub_end, h_sub, t_cycle_end, h_sub, xloc=xloc.bar_time, color=colHigh, style=line.style_dashed, width=1)
    l_low  := line.new(t_sub_end, l_sub, t_cycle_end, l_sub, xloc=xloc.bar_time, color=colLow, style=line.style_dashed, width=1)
    l_eq   := line.new(t_sub_end, eq_price_draw, t_cycle_end, eq_price_draw, xloc=xloc.bar_time, color=colEQ, style=line.style_dotted, width=2)

// ══════════════════════════════════════════════════════════════════════════════
// SIGNAL DETECTION
// ══════════════════════════════════════════════════════════════════════════════

// Calculate EQ and zones
eq_price = (h_sub + l_sub) / 2
in_discount = close < eq_price
in_premium = close > eq_price
range_40m = h_sub - l_sub

// Range filter check
range_ok = minRangeATR == 0 or range_40m >= (atr_val * minRangeATR)

// Liquidity sweep detection
sweep_high_now = false
sweep_low_now = false

if in_execution and not trade_taken
    // Sweep of 40m High (bearish setup)
    if high > h_sub and not high_swept
        high_swept := true
        sweep_bar := bar_index
        sweep_high_now := true
        total_sweeps := total_sweeps + 1

    // Sweep of 40m Low (bullish setup)
    if low < l_sub and not low_swept
        low_swept := true
        sweep_bar := bar_index
        sweep_low_now := true
        total_sweeps := total_sweeps + 1

// Plot sweep markers
plotshape(sweep_high_now and showSweeps, title="High Sweep", location=location.abovebar, style=shape.xcross, size=size.small, color=color.red, text="SWEEP")
plotshape(sweep_low_now and showSweeps, title="Low Sweep", location=location.belowbar, style=shape.xcross, size=size.small, color=color.green, text="SWEEP")

// ── ENTRY SIGNAL DETECTION ─────────────────────────────────────────────────────
var float entry_price = na
var float stop_level = na
var float tp_level = na

buy_signal = false
sell_signal = false

if in_execution and not trade_taken

    // ── BUY LOGIC ──
    if low_swept and not onlyShorts
        bool entry_trigger = false

        if entryMode == "Sweep Only"
            // Enter immediately on sweep
            entry_trigger := sweep_low_now
        else if entryMode == "Sweep + Reversal"
            // Enter when we get a bullish candle after sweep
            entry_trigger := bar_index > sweep_bar and is_bullish
        else // Full CSD
            // Enter when bearish candle is traded above
            entry_trigger := bar_index > sweep_bar and is_bearish[1] and (close > high[1] or high > high[1])

        if entry_trigger
            stop_calc = stopAtLow ? l_sub : (close - fixedStopPts)
            stop_dist = math.abs(close - stop_calc)
            zone_ok = not reqEQConfirm or in_discount
            risk_ok = maxRiskPts == 0 or stop_dist <= maxRiskPts

            if zone_ok and risk_ok and range_ok
                buy_signal := true
                trade_taken := true
                trade_direction := 1
                entry_price := close
                stop_level := stop_calc
                tp_level := close + takeProfitPts
                total_signals := total_signals + 1

    // ── SELL LOGIC ──
    if high_swept and not onlyLongs
        bool entry_trigger = false

        if entryMode == "Sweep Only"
            entry_trigger := sweep_high_now
        else if entryMode == "Sweep + Reversal"
            entry_trigger := bar_index > sweep_bar and is_bearish
        else // Full CSD
            entry_trigger := bar_index > sweep_bar and is_bullish[1] and (close < low[1] or low < low[1])

        if entry_trigger
            stop_calc = stopAtLow ? h_sub : (close + fixedStopPts)
            stop_dist = math.abs(stop_calc - close)
            zone_ok = not reqEQConfirm or in_premium
            risk_ok = maxRiskPts == 0 or stop_dist <= maxRiskPts

            if zone_ok and risk_ok and range_ok
                sell_signal := true
                trade_taken := true
                trade_direction := -1
                entry_price := close
                stop_level := stop_calc
                tp_level := close - takeProfitPts
                total_signals := total_signals + 1

// ══════════════════════════════════════════════════════════════════════════════
// STRATEGY EXECUTION
// ══════════════════════════════════════════════════════════════════════════════

if buy_signal
    strategy.entry("Long", strategy.long)
    if useStopLoss and useTakeProfit
        strategy.exit("Long Exit", "Long", stop=stop_level, limit=tp_level)
    else if useStopLoss
        strategy.exit("Long SL", "Long", stop=stop_level)
    else if useTakeProfit
        strategy.exit("Long TP", "Long", limit=tp_level)

if sell_signal
    strategy.entry("Short", strategy.short)
    if useStopLoss and useTakeProfit
        strategy.exit("Short Exit", "Short", stop=stop_level, limit=tp_level)
    else if useStopLoss
        strategy.exit("Short SL", "Short", stop=stop_level)
    else if useTakeProfit
        strategy.exit("Short TP", "Short", limit=tp_level)

// Close at end of session
if time >= t_sess_end and strategy.position_size != 0
    strategy.close_all("Session End")

// ══════════════════════════════════════════════════════════════════════════════
// VISUAL MARKERS
// ══════════════════════════════════════════════════════════════════════════════

plotshape(buy_signal, title="Buy Signal", location=location.belowbar, style=shape.triangleup, size=size.normal, color=color.lime, text="BUY")
plotshape(sell_signal, title="Sell Signal", location=location.abovebar, style=shape.triangledown, size=size.normal, color=color.red, text="SELL")

// Plot levels
plot(in_execution and showLevels ? h_sub : na, "40m High", color=colHigh, style=plot.style_linebr, linewidth=1)
plot(in_execution and showLevels ? l_sub : na, "40m Low", color=colLow, style=plot.style_linebr, linewidth=1)
plot(in_execution and showLevels ? eq_price : na, "EQ", color=colEQ, style=plot.style_linebr, linewidth=1)

// Background color for phases
bgcolor(in_accumulation and showBoxes ? color.new(color.yellow, 95) : na, title="Accumulation Phase")
bgcolor(in_execution and showBoxes ? color.new(color.blue, 97) : na, title="Execution Phase")

// ══════════════════════════════════════════════════════════════════════════════
// DEBUG TABLE
// ══════════════════════════════════════════════════════════════════════════════
var table debugTable = table.new(position.top_right, 2, 8, bgcolor=color.new(color.black, 80), border_width=1)

if barstate.islast and showDebugTable
    cycle_num = i_cyc + 1
    phase_text = in_accumulation ? "ACCUM" : (in_execution ? "EXEC" : "OUT")

    table.cell(debugTable, 0, 0, "Cycle #", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 0, str.tostring(cycle_num), text_color=color.white, text_size=size.small)
    table.cell(debugTable, 0, 1, "Phase", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 1, phase_text, text_color=in_accumulation ? color.yellow : color.lime, text_size=size.small)
    table.cell(debugTable, 0, 2, "40m High", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 2, str.tostring(h_sub, "#.##"), text_color=colHigh, text_size=size.small)
    table.cell(debugTable, 0, 3, "40m Low", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 3, str.tostring(l_sub, "#.##"), text_color=colLow, text_size=size.small)
    table.cell(debugTable, 0, 4, "High Swept", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 4, high_swept ? "YES" : "NO", text_color=high_swept ? color.lime : color.red, text_size=size.small)
    table.cell(debugTable, 0, 5, "Low Swept", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 5, low_swept ? "YES" : "NO", text_color=low_swept ? color.lime : color.red, text_size=size.small)
    table.cell(debugTable, 0, 6, "Total Sweeps", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 6, str.tostring(total_sweeps), text_color=color.white, text_size=size.small)
    table.cell(debugTable, 0, 7, "Total Signals", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 7, str.tostring(total_signals), text_color=color.white, text_size=size.small)
