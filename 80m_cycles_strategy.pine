//@version=6
strategy("80m Cycles Strategy", overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 100, initial_capital = 10000, commission_type = strategy.commission.cash_per_contract, commission_value = 2.5, slippage = 1)

// ══════════════════════════════════════════════════════════════════════════════
// 80-MINUTE CYCLE STRATEGY - BACKTESTER
// ══════════════════════════════════════════════════════════════════════════════
// Backtestable version of the 80-minute cycle strategy.
// Uses CSD signals for entries with configurable stop loss and take profit.
// ══════════════════════════════════════════════════════════════════════════════

// ── STRATEGY INPUTS ────────────────────────────────────────────────────────────
grp_strat = "Strategy Settings"
useStopLoss    = input.bool(true, "Use Stop Loss", group = grp_strat)
stopAtLow      = input.bool(true, "Stop at 40m Low/High (vs Fixed Points)", group = grp_strat)
fixedStopPts   = input.float(20.0, "Fixed Stop Loss (Points)", minval=1.0, group = grp_strat)
useTakeProfit  = input.bool(true, "Use Take Profit", group = grp_strat)
takeProfitPts  = input.float(70.0, "Take Profit (Points)", minval=10.0, group = grp_strat)
useTrailStop   = input.bool(false, "Use Trailing Stop", group = grp_strat)
trailPts       = input.float(30.0, "Trail Points", minval=5.0, group = grp_strat)
maxRiskPts     = input.float(25.0, "Max Risk Filter (skip if stop > X pts)", minval=0.0, group = grp_strat, tooltip="Set to 0 to disable filter")
onlyLongs      = input.bool(false, "Long Only", group = grp_strat)
onlyShorts     = input.bool(false, "Short Only", group = grp_strat)

// ── TIME INPUTS ────────────────────────────────────────────────────────────────
grp_time   = "Time Settings (EST)"
tz         = "America/New_York"
startH     = input.int(7,  "Session Start Hour", minval=0, maxval=23, group = grp_time)
startM     = input.int(0,  "Session Start Minute", minval=0, maxval=59, group = grp_time)
endH       = input.int(16, "Session End Hour", minval=0, maxval=23, group = grp_time)
endM       = input.int(0,  "Session End Minute", minval=0, maxval=59, group = grp_time)

// ── FILTER INPUTS ──────────────────────────────────────────────────────────────
grp_filter = "Trade Filters"
reqEQConfirm   = input.bool(true, "Require Price in Discount/Premium Zone", group = grp_filter, tooltip="Buy only in discount (below EQ), sell only in premium (above EQ)")
minRangeATR    = input.float(0.5, "Min 40m Range (ATR multiplier)", minval=0.0, group = grp_filter, tooltip="Skip cycles with small range. Set to 0 to disable.")

// ── VISUAL INPUTS ──────────────────────────────────────────────────────────────
grp_visual = "Visual Settings"
showBoxes      = input.bool(true, "Show Cycle Boxes", group = grp_visual)
showLevels     = input.bool(true, "Show Level Lines", group = grp_visual)
col80m         = input.color(color.new(color.gray, 92), "80min Cycle Box", group = grp_visual)
col40m         = input.color(color.new(color.rgb(100, 140, 160), 88), "Accumulation Phase", group = grp_visual)
colHigh        = input.color(color.red, "40m High", group = grp_visual)
colLow         = input.color(color.green, "40m Low", group = grp_visual)
colEQ          = input.color(color.orange, "Equilibrium", group = grp_visual)

// ── TIME CALCULATIONS ──────────────────────────────────────────────────────────
y = year(time, tz)
m = month(time, tz)
d = dayofmonth(time, tz)

t_sess_start = timestamp(tz, y, m, d, startH, startM, 0)
t_sess_end   = timestamp(tz, y, m, d, endH, endM, 0)

ms_80 = 80 * 60 * 1000
ms_40 = 40 * 60 * 1000

in_session_window = time >= t_sess_start and time < t_sess_end

// ── CYCLE INDEX CALCULATION ────────────────────────────────────────────────────
i_cyc = if in_session_window
    ms_elapsed = time - t_sess_start
    math.floor(ms_elapsed / ms_80)
else
    -1

is_new_cycle = i_cyc != i_cyc[1] and i_cyc >= 0

t_cycle_start = t_sess_start + (i_cyc * ms_80)
t_cycle_end   = t_cycle_start + ms_80
t_sub_end     = t_cycle_start + ms_40

// Phase detection
in_accumulation = time >= t_cycle_start and time < t_sub_end
in_execution    = time >= t_sub_end and time < t_cycle_end

// ── STATE VARIABLES ────────────────────────────────────────────────────────────
var box b_cyc = na
var box b_sub = na
var float h_cyc = na, var float l_cyc = na
var float h_sub = na, var float l_sub = na
var float cycle_open = na

// Level lines
var line l_high = na
var line l_low = na
var line l_eq = na

// Signal state
var bool high_swept = false
var bool low_swept = false
var int sweep_bar = na
var bool csd_triggered = false
var int trade_direction = 0  // 1 = long, -1 = short

// ATR for filters
atr_val = ta.atr(14)

// Candle type detection
is_bullish = close > open
is_bearish = close < open

// ══════════════════════════════════════════════════════════════════════════════
// CYCLE MANAGEMENT
// ══════════════════════════════════════════════════════════════════════════════

if in_session_window
    // NEW CYCLE START
    if is_new_cycle
        // Reset state
        h_cyc := high
        l_cyc := low
        h_sub := high
        l_sub := low
        cycle_open := open

        // Reset signal state
        high_swept := false
        low_swept := false
        sweep_bar := na
        csd_triggered := false
        trade_direction := 0

        // Delete previous lines
        line.delete(l_high)
        line.delete(l_low)
        line.delete(l_eq)
        box.delete(b_cyc)
        box.delete(b_sub)

        // Create boxes
        if showBoxes
            b_cyc := box.new(t_cycle_start, high, t_cycle_end, low, xloc=xloc.bar_time, border_color=color.gray, bgcolor=col80m)
            b_sub := box.new(t_cycle_start, high, t_sub_end, low, xloc=xloc.bar_time, border_color=na, bgcolor=col40m)

    // Update cycle high/low
    new_h_cyc = math.max(h_cyc, high)
    new_l_cyc = math.min(l_cyc, low)

    if new_h_cyc != h_cyc
        h_cyc := new_h_cyc
        if showBoxes
            box.set_top(b_cyc, h_cyc)

    if new_l_cyc != l_cyc
        l_cyc := new_l_cyc
        if showBoxes
            box.set_bottom(b_cyc, l_cyc)

    // Update 40m box (accumulation only)
    if in_accumulation
        new_h_sub = math.max(h_sub, high)
        new_l_sub = math.min(l_sub, low)

        if new_h_sub != h_sub
            h_sub := new_h_sub
            if showBoxes
                box.set_top(b_sub, h_sub)

        if new_l_sub != l_sub
            l_sub := new_l_sub
            if showBoxes
                box.set_bottom(b_sub, l_sub)

// ── LEVEL PROJECTION ───────────────────────────────────────────────────────────
is_phase_transition = in_execution and in_accumulation[1]

if is_phase_transition and showLevels
    eq_price = (h_sub + l_sub) / 2
    l_high := line.new(t_sub_end, h_sub, t_cycle_end, h_sub, xloc=xloc.bar_time, color=colHigh, style=line.style_dashed, width=1)
    l_low  := line.new(t_sub_end, l_sub, t_cycle_end, l_sub, xloc=xloc.bar_time, color=colLow, style=line.style_dashed, width=1)
    l_eq   := line.new(t_sub_end, eq_price, t_cycle_end, eq_price, xloc=xloc.bar_time, color=colEQ, style=line.style_dotted, width=2)

// ══════════════════════════════════════════════════════════════════════════════
// SIGNAL DETECTION
// ══════════════════════════════════════════════════════════════════════════════

// Calculate EQ and zones
eq_price = (h_sub + l_sub) / 2
in_discount = close < eq_price
in_premium = close > eq_price
range_40m = h_sub - l_sub

// Range filter check
range_ok = minRangeATR == 0 or range_40m >= (atr_val * minRangeATR)

// Liquidity sweep detection
if in_execution and not csd_triggered
    // Sweep of 40m High (bearish setup)
    if high > h_sub and not high_swept
        high_swept := true
        sweep_bar := bar_index

    // Sweep of 40m Low (bullish setup)
    if low < l_sub and not low_swept
        low_swept := true
        sweep_bar := bar_index

// ── CSD SIGNAL DETECTION ───────────────────────────────────────────────────────
var float entry_price = na
var float stop_level = na
var float tp_level = na

// BUY SIGNAL
buy_csd = false
if in_execution and not csd_triggered and low_swept and bar_index > sweep_bar
    if is_bearish[1] and (close > high[1] or high > high[1])
        // Calculate stop
        stop_calc = stopAtLow ? l_sub : (close - fixedStopPts)
        stop_dist = close - stop_calc

        // Zone filter
        zone_ok = not reqEQConfirm or in_discount

        // Risk filter
        risk_ok = maxRiskPts == 0 or stop_dist <= maxRiskPts

        // Direction filter
        dir_ok = not onlyShorts

        if zone_ok and risk_ok and range_ok and dir_ok
            buy_csd := true
            csd_triggered := true
            trade_direction := 1
            entry_price := close
            stop_level := stop_calc
            tp_level := close + takeProfitPts

// SELL SIGNAL
sell_csd = false
if in_execution and not csd_triggered and high_swept and bar_index > sweep_bar
    if is_bullish[1] and (close < low[1] or low < low[1])
        // Calculate stop
        stop_calc = stopAtLow ? h_sub : (close + fixedStopPts)
        stop_dist = stop_calc - close

        // Zone filter
        zone_ok = not reqEQConfirm or in_premium

        // Risk filter
        risk_ok = maxRiskPts == 0 or stop_dist <= maxRiskPts

        // Direction filter
        dir_ok = not onlyLongs

        if zone_ok and risk_ok and range_ok and dir_ok
            sell_csd := true
            csd_triggered := true
            trade_direction := -1
            entry_price := close
            stop_level := stop_calc
            tp_level := close - takeProfitPts

// ══════════════════════════════════════════════════════════════════════════════
// STRATEGY EXECUTION
// ══════════════════════════════════════════════════════════════════════════════

// Entry signals
if buy_csd
    strategy.entry("Long", strategy.long)

    if useStopLoss and useTakeProfit
        strategy.exit("Long Exit", "Long", stop=stop_level, limit=tp_level, trail_points=useTrailStop ? trailPts : na, trail_offset=useTrailStop ? trailPts * 0.5 : na)
    else if useStopLoss
        strategy.exit("Long SL", "Long", stop=stop_level)
    else if useTakeProfit
        strategy.exit("Long TP", "Long", limit=tp_level)

if sell_csd
    strategy.entry("Short", strategy.short)

    if useStopLoss and useTakeProfit
        strategy.exit("Short Exit", "Short", stop=stop_level, limit=tp_level, trail_points=useTrailStop ? trailPts : na, trail_offset=useTrailStop ? trailPts * 0.5 : na)
    else if useStopLoss
        strategy.exit("Short SL", "Short", stop=stop_level)
    else if useTakeProfit
        strategy.exit("Short TP", "Short", limit=tp_level)

// Close at end of session (optional safety)
if time >= t_sess_end and strategy.position_size != 0
    strategy.close_all("Session End")

// Close at end of cycle (optional - uncomment to use)
// if is_new_cycle and strategy.position_size != 0
//     strategy.close_all("Cycle End")

// ══════════════════════════════════════════════════════════════════════════════
// VISUAL MARKERS
// ══════════════════════════════════════════════════════════════════════════════

// Plot entry signals on chart
plotshape(buy_csd, title="Buy CSD", location=location.belowbar, style=shape.triangleup, size=size.normal, color=color.lime, text="BUY")
plotshape(sell_csd, title="Sell CSD", location=location.abovebar, style=shape.triangledown, size=size.normal, color=color.red, text="SELL")

// Plot levels
plot(in_execution and showLevels ? h_sub : na, "40m High", color=colHigh, style=plot.style_linebr, linewidth=1)
plot(in_execution and showLevels ? l_sub : na, "40m Low", color=colLow, style=plot.style_linebr, linewidth=1)
plot(in_execution and showLevels ? eq_price : na, "EQ", color=colEQ, style=plot.style_linebr, linewidth=1)

// Background color for phases
bgcolor(in_accumulation and showBoxes ? color.new(color.yellow, 95) : na, title="Accumulation Phase")
bgcolor(in_execution and showBoxes ? color.new(color.blue, 97) : na, title="Execution Phase")

// ══════════════════════════════════════════════════════════════════════════════
// INFO TABLE
// ══════════════════════════════════════════════════════════════════════════════
var table infoTable = table.new(position.top_right, 2, 5, bgcolor=color.new(color.black, 80), border_width=1)

if barstate.islast and in_session_window
    cycle_num = i_cyc + 1
    phase_text = in_accumulation ? "ACCUM" : "EXEC"

    table.cell(infoTable, 0, 0, "Cycle", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 0, str.tostring(cycle_num), text_color=color.white, text_size=size.small)
    table.cell(infoTable, 0, 1, "Phase", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 1, phase_text, text_color=in_accumulation ? color.yellow : color.lime, text_size=size.small)
    table.cell(infoTable, 0, 2, "40m Range", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(range_40m, "#.##"), text_color=color.white, text_size=size.small)
    table.cell(infoTable, 0, 3, "EQ", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 3, str.tostring(eq_price, "#.##"), text_color=colEQ, text_size=size.small)
    table.cell(infoTable, 0, 4, "Position", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 4, strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "FLAT", text_color=strategy.position_size > 0 ? color.lime : strategy.position_size < 0 ? color.red : color.gray, text_size=size.small)
