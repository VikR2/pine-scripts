//@version=6
strategy("80m Cycles Strategy", overlay=true,
     default_qty_type=strategy.fixed,
     default_qty_value=1,
     initial_capital=10000,
     pyramiding=0,
     calc_on_every_tick=false)

//------------------------------------------------------------------------------
// INPUTS
//------------------------------------------------------------------------------
i_startHour = input.int(7, "Session Start Hour", minval=0, maxval=23)
i_endHour = input.int(16, "Session End Hour", minval=0, maxval=23)
i_stopPts = input.float(30.0, "Stop Loss (points)", minval=1)
i_tpPts = input.float(70.0, "Take Profit (points)", minval=1)
i_tz = "America/New_York"

//------------------------------------------------------------------------------
// TIME FUNCTIONS
//------------------------------------------------------------------------------
f_inSession() =>
    h = hour(time, i_tz)
    h >= i_startHour and h < i_endHour

f_getCyclePhase() =>
    // Returns: 0=outside, 1=accumulation, 2=execution
    if not f_inSession()
        0
    else
        h = hour(time, i_tz)
        m = minute(time, i_tz)
        totalMins = (h - i_startHour) * 60 + m
        cycleMin = totalMins % 80
        cycleMin < 40 ? 1 : 2

//------------------------------------------------------------------------------
// PHASE TRACKING
//------------------------------------------------------------------------------
phase = f_getCyclePhase()
inAccum = phase == 1
inExec = phase == 2

// Detect phase transitions
wasAccum = inAccum[1] or (phase[1] == 0 and inAccum)
justEnteredExec = inExec and not inExec[1]
justEnteredAccum = inAccum and not inAccum[1]

//------------------------------------------------------------------------------
// RANGE TRACKING - Using ta.highest/ta.lowest with lookback
//------------------------------------------------------------------------------
// Count bars in current accumulation phase
var int accumBars = 0
if justEnteredAccum
    accumBars := 1
else if inAccum
    accumBars := accumBars + 1
else if justEnteredExec
    accumBars := accumBars  // Keep the count
else if not inExec
    accumBars := 0

// Get range from accumulation period
lookback = math.max(1, accumBars)
accumHigh = ta.highest(high, lookback)
accumLow = ta.lowest(low, lookback)

// Lock in values at phase transition
var float rangeHigh = na
var float rangeLow = na

if justEnteredExec
    rangeHigh := accumHigh[1]
    rangeLow := accumLow[1]

//------------------------------------------------------------------------------
// SWEEP DETECTION
//------------------------------------------------------------------------------
sweepHigh = inExec and not na(rangeHigh) and high > rangeHigh
sweepLow = inExec and not na(rangeLow) and low < rangeLow

// Track if we already traded this cycle
var bool tradedThisCycle = false
if justEnteredAccum or justEnteredExec
    tradedThisCycle := false

//------------------------------------------------------------------------------
// STRATEGY LOGIC
//------------------------------------------------------------------------------
longCondition = sweepLow and not tradedThisCycle and strategy.position_size == 0
shortCondition = sweepHigh and not tradedThisCycle and strategy.position_size == 0

if longCondition
    tradedThisCycle := true
    strategy.entry("Long", strategy.long)

if shortCondition
    tradedThisCycle := true
    strategy.entry("Short", strategy.short)

// Exit logic using strategy.position_avg_price
if strategy.position_size > 0
    stopPrice = strategy.position_avg_price - i_stopPts
    tpPrice = strategy.position_avg_price + i_tpPts
    strategy.exit("Exit Long", "Long", stop=stopPrice, limit=tpPrice)

if strategy.position_size < 0
    stopPrice = strategy.position_avg_price + i_stopPts
    tpPrice = strategy.position_avg_price - i_tpPts
    strategy.exit("Exit Short", "Short", stop=stopPrice, limit=tpPrice)

// Close at end of session
if not f_inSession() and strategy.position_size != 0
    strategy.close_all("Session Close")

//------------------------------------------------------------------------------
// PLOTS
//------------------------------------------------------------------------------
plotshape(longCondition, "Long Signal", shape.triangleup, location.belowbar, color.lime, size=size.small)
plotshape(shortCondition, "Short Signal", shape.triangledown, location.abovebar, color.red, size=size.small)

plot(inExec ? rangeHigh : na, "Range High", color.red, 2)
plot(inExec ? rangeLow : na, "Range Low", color.green, 2)

bgcolor(inAccum ? color.new(color.yellow, 90) : inExec ? color.new(color.blue, 90) : na)

// Debug info
plotchar(sweepLow, "Sweep Low", "▼", location.abovebar, color.green, size=size.tiny)
plotchar(sweepHigh, "Sweep High", "▲", location.belowbar, color.red, size=size.tiny)
